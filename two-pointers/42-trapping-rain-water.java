// LeetCode: перед вставкой переименуй класс в Solution
//
// 42. Trapping Rain Water (Hard)
//
// В отличие от задачи 11 (Container With Most Water) — тут реальный рельеф.
// Палки это блоки, они занимают место. Вода застревает в ямках между блоками.
//
// ВАЖНО: вода — это НЕ один большой бассейн между самыми высокими стенками!
// Вода копится в каждой ямке отдельно. Поэтому нельзя найти две макс. стенки
// и посчитать одной формулой. Нужно пройти по КАЖДОЙ позиции и спросить:
// "тут ямка? сколько воды застряло?"
//
// Формула для каждой позиции: вода[i] = min(maxLeft, maxRight) - height[i]
//   maxLeft / maxRight — стенки (до куда поднимется вода)
//   height[i] — блок под ногами (вытесняет воду)
//   min(стенки) — вода перельётся через меньшую стенку
//
// Подход: Two Pointers — идём с двух сторон, двигаем меньший указатель.
// Если height[left] < height[right] — вода слева ограничена maxLeft
// (справа гарантированно есть стенка >= height[right], она не пустит воду).
// Аналогично для правой стороны.
//
// Проверка "есть вода или нет" не нужна — математика сама это решает:
//   Стоишь на стенке → max обновился → max - height = 0 (нет воды)
//   Стоишь в ямке → max не изменился → max - height > 0 (вода!)
class TrappingRainWater {
    // Временная сложность: O(n) — один проход двумя указателями
    // Пространственная сложность: O(1) — только переменные
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;

        // максимальные стенки слева и справа от текущей позиции
        int maxLeft = 0;
        int maxRight = 0;

        // сумма воды во всех ямках
        int result = 0;

        // идём с двух сторон навстречу
        while (left < right) {
            // двигаем тот указатель, чья высота меньше
            if (height[left] < height[right]) {
                // обновляем максимум слева (если стоим на новой стенке — max вырастет)
                maxLeft = Math.max(maxLeft, height[left]);
                // вода = уровень воды (maxLeft) минус блок под ногами
                // если это стенка: maxLeft только что обновился → разница = 0
                // если это ямка: maxLeft остался прежним → разница > 0 = вода
                result += maxLeft - height[left];
                ++left;
            } else {
                // аналогично для правой стороны
                maxRight = Math.max(maxRight, height[right]);
                result += maxRight - height[right];
                --right;
            }
        }

        return result;
    }

    static void main(String[] args) {
        var sol = new TrappingRainWater();

        // Пример 1: [0,1,0,2,1,0,1,3,2,1,2,1] → 6
        System.out.println(sol.trap(new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}));

        // Пример 2: [4,2,0,3,2,5] → 9
        System.out.println(sol.trap(new int[]{4, 2, 0, 3, 2, 5}));
    }
}
